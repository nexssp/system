"use strict";const{spawnSync:spawnSync}=require("child_process"),{existsSync:existsSync}=require("fs");require("@nexssp/extend")("array");const defaultOptions={};function debugOutput(e,r,s,o){console.log(o?"\nResult WITH STDERR:":`\nResult WITHOUT STDERR:\nExecuted: ${e}\nOptions: `,r,`process.cwd(): ${process.cwd()}`,"\nSTDOUT:\n",s,"|END STDOUT"),o&&console.error(o)}function nSpawn(e,r={}){const{parseArgsStringToArgv:s}=require("string-argv");let o=s(e).argStripQuotes();o="win32"===process.platform?o.map((e=>~e.indexOf("=")?`${e.replace("=",'="')}"`:e)):o.map((e=>~e.indexOf("=")?`${e.replace("=","='")}'`:e));const[n,...t]=o;if(nSpawn.debug&&(console.log("command:",e),console.log("cmd:",n),console.log("args:",t)),"win32"!==process.platform?Object.assign(r,{shell:process.shell}):Object.assign(r,{shell:!0}),r.cwd&&!existsSync(r.cwd))return new Error("Folder passed to 'nSpawn' does not exist.");let c,a="",p="",i=0;r.stdio="pipe";try{c=spawnSync(`${n}`,t,r)}catch(e){console.log("Error catched:",e),process.exit(1)}if(!c.error)return p=c.stdout.toString(),a=c.stderr.toString(),i=c.status,nSpawn.debug&&debugOutput(e,r,p,a),{exitCode:i,stdout:p,stderr:a};switch(c.error.code){case"ENOENT":throw new Error(`Program has not been found: ${c.error}, path: ${c.error.path}`);case"EACCES":throw new Error(`Permission denied: ${c.error}, path: ${c.error.path}`);default:throw new Error(c.error)}}"win32"!==process.platform&&Object.assign(defaultOptions,{shell:process.shell}),nSpawn.debug=!1,module.exports={nSpawn:nSpawn};