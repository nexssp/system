"use strict";const{spawnSync:spawnSync}=require("child_process"),{existsSync:existsSync}=require("fs"),defaultOptions={};function debugOutput(r,e,s,o){e.stdio||(e.stdio="pipe"),console.log(o?"\nResult WITH STDERR:":`\nResult WITHOUT STDERR:\nExecuted: ${r}\nOptions: `,e,`process.cwd(): ${process.cwd()}`,"\nSTDOUT:\n",s,"|END STDOUT"),o&&console.error(o)}function nSpawn(r,e={}){e.stdio||(e.stdio="pipe");const{parseArgsStringToArgv:s}=require("string-argv");let o=s(r);o="win32"===process.platform?o.map((r=>r.replace(/='(.*)'/,'="$1"'))):o.map((r=>r.replace(/="(.*)"/,"='$1'")));const[t,...n]=o;if(nSpawn.debug&&(console.log("command:",r),console.log("cmd:",t),console.log("args:",n)),"win32"!==process.platform?Object.assign(e,{shell:process.shell}):Object.assign(e,{shell:!0}),e.cwd&&!existsSync(e.cwd))return new Error("Folder passed to 'nSpawn' does not exist.");const c=e.stripTerminalColors;delete e.stripTerminalColors;let a,i="",p="",l=0;try{a=spawnSync(`${t}`,n,e)}catch(r){console.log("Error catched:",r),process.exit(1)}if(!a.error)return a.stdout&&(p=a.stdout.toString()),a.stderr&&(i=a.stderr.toString()),a.status&&(l=a.status),c&&(p=p.stripTerminalColors(),i=i.stripTerminalColors()),nSpawn.debug&&debugOutput(r,e,p,i),{exitCode:l,stdout:p,stderr:i,cmd:t,args:n,command:r};switch(a.error.code){case"ENOENT":throw new Error(`Program has not been found: ${a.error}, path: ${a.error.path}.`);case"EACCES":throw new Error(`Permission denied: ${a.error}, path: ${a.error.path}`);default:throw new Error(a.error)}}"win32"!==process.platform&&Object.assign(defaultOptions,{shell:process.shell}),nSpawn.debug=!1,module.exports={nSpawn:nSpawn};